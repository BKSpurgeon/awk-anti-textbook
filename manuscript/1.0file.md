# Files and Sales

We are going to play with the output of `ls -l` command in an attempt to figure out what all we can do with the wonderful language which is called awk. We are also going to play with the sales.csv file which we created in chapter one.

* Finding all the lines which contain J
        
        code ⏰  awk '/J/ {print}' sales.csv
        Jan,100
        June,1000
        July,10


Please run `ls -l` on your commandline and see what the output is. For me, it is showing it as 

    awk book ⏰  ls -l
    total 1856
    -rw-r--r--  1 surajpatil  staff     403 Aug 28  2016 CONTRIBUTORS.md
    -rw-r--r--  1 surajpatil  staff    5313 Mar 25  2017 README.md
    -rw-r--r--  1 surajpatil  staff    1641 Jul 11 23:53 SUMMARY.md
    -rw-r--r--@ 1 surajpatil  staff      60 Jul 11 23:52 awkbook.code-workspace
    -rw-r--r--  1 surajpatil  staff     119 Dec 12  2016 book.json
    drwxr-xr-x  5 surajpatil  staff     160 Jul 12 21:41 code
    -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
    -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf
    drwxr-xr-x  8 surajpatil  staff     256 Jul 12 23:21 manuscript

* Print the names of files that are larger than 300 bytes

        book ⏰  ls -l | awk '$5>300 {print}'
        
        -rw-r--r--  1 surajpatil  staff     403 Aug 28  2016 CONTRIBUTORS.md
        -rw-r--r--  1 surajpatil  staff    5313 Mar 25  2017 README.md
        -rw-r--r--  1 surajpatil  staff    1641 Jul 11 23:53 SUMMARY.md
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf

Note: Till now we saw how to use awk on files. In the above command, we are passing the output of a command (ls, in this case) to awk. This is called piping and it is a very fundamental unix feature.

The delimiter is space by default, so we did not have to override it. $5 is the fifth field in the output, which is the size.

We saw that a block of code is enclosed within `{}`. Now, in the above code, we have run `'$5>300 {print}'`. This tells awk to print the lines only if the fifth field is greater than 300.

* Print the names of files that has the character c in its name somewhere.

note: this is equivalent to the command `ls -l | grep c`

        awk book ⏰  ls -l | awk '$NF ~ /c/ {print}'
        drwxr-xr-x  5 surajpatil  staff     160 Jul 12 21:41 code
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf

* Print the names of file which don't have `c` in their name

        awk book ⏰  ls -l | awk '$NF !~ /c/ {print}'

The `~` syntax is widely used when we want to _match_ the field with some particular value. Here, it is just checking if the character `c` is present in the line or not.

Note: We have used $NF, you can experiment with $1 till $8

* Run two commands at the same time

        awk book ⏰  ls -l | awk '$NF ~ /c/ {print} $5>300 {print}'
        -rw-r--r--  1 surajpatil  staff     403 Aug 28  2016 CONTRIBUTORS.md
        -rw-r--r--  1 surajpatil  staff    5313 Mar 25  2017 README.md
        -rw-r--r--  1 surajpatil  staff    1641 Jul 11 23:53 SUMMARY.md
        -rw-r--r--@ 1 surajpatil  staff      60 Jul 11 23:52 awkbook.code-workspace
        drwxr-xr-x  5 surajpatil  staff     160 Jul 12 21:41 code
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf
        drwxr-xr-x  8 surajpatil  staff     256 Jul 12 23:21 manuscript

Note that this does not make it a logical and. It just executes both the scripts one after another.

Finding out the total size of all the files in your current directory

* Logical or in awk

        awk book ⏰  ls -l | awk '$NF ~ /c/ ||  $5>300 {print}'
        -rw-r--r--  1 surajpatil  staff     403 Aug 28  2016 CONTRIBUTORS.md
        -rw-r--r--  1 surajpatil  staff    5313 Mar 25  2017 README.md
        -rw-r--r--  1 surajpatil  staff    1641 Jul 11 23:53 SUMMARY.md
        -rw-r--r--@ 1 surajpatil  staff      60 Jul 11 23:52 awkbook.code-workspace
        drwxr-xr-x  5 surajpatil  staff     160 Jul 12 21:41 code
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf
        drwxr-xr-x  8 surajpatil  staff     256 Jul 12 23:21 manuscript

What happens in the above code is that the condition $NF ~ /c/ ||  $5>300  is evaluated first and THEN the print statement gets executed.

* Logical and in awk

        awk book ⏰  ls -l | awk '$NF ~ /c/ &&  $5>300 {print}'
        -rw-r--r--  1 surajpatil  staff  230613 Aug 23  2016 cover.jpg
        -rw-r--r--  1 surajpatil  staff  692088 Aug 23  2016 cover.xcf

Note: If you want to print only specific fields, please print specific fields

* File names starting with c

        awk book ⏰  ls -l | awk '$NF ~ /^a/  {print}'
        -rw-r--r--@ 1 surajpatil  staff      60 Jul 11 23:52 awkbook.code-workspace 

In regular expressions ^ is used to match the start of line and $ is used to match end of line. So when we say match with /^c/, we say print all lines that start with c.

When we give the below command, it prints all the *.md files. This is equivalent to `ls -l *.md`

        awk book ⏰  ls -l | awk '$NF ~ /.md$/  {print}'
        -rw-r--r--  1 surajpatil  staff     403 Aug 28  2016 CONTRIBUTORS.md
        -rw-r--r--  1 surajpatil  staff    5313 Mar 25  2017 README.md
        -rw-r--r--  1 surajpatil  staff    1641 Jul 11 23:53 SUMMARY.md

* File names ending with md
        
        ls -l | awk '{sum+=$5} END {print sum}'

* Finding the sum of sales for all lines that has J in it.

        awk -F"," 'BEGIN{sales=0} /J/ {sales+=$2} END {print sales}' sales.csv

BEGIN: The block that is executed _once_ at the start of the code. All the variable assignment should ideally be done here

/J/ {}: this block is not in BEGIN or END, thus, it is executed 

END: The block that is executed _once_ at the end of the code. All the printing should go there.

awk will read the sales.csv with the delimiter of comma, it'll initialize a variable called sales. Then, for each line in sales.csv, awk will run `/J/ {sales+=$2}` i.e. increment the sales variable. At the end, we print it.

* Printing data into seperate files according to Financial Quarters

A financial year has four quarters, Q1 to Q4 of three months each. What we want to do is split our file into four such files depending on the year.

        code ⏰  awk -F"," '/Jan/||/Feb/||/Mar/ {print}' sales.csv > Q1.csv
        code ⏰  cat Q1.csv
        Jan,100
        Feb,200
        March,100

Exercise: Write the code for other three quarters. This is a bit cumbersome code, in the next chapters when we go to a bit advanced awk, we'll learn how to do all this in one line of awk code.

* Split the data according to sales

If the sales of a particular month is less than 500, write it to 500.csv, if greater than 500 and less than 1000 then in 1000.csv, any value above it should go in large.csv

        code ⏰  awk -F"," '$2 <=500 {print}' sales.csv > 500.csv
        code ⏰  cat 500.csv
        Jan,100
        Feb,200
        March,100
        April,50
        July,10
        August,20
        September,456
        October,134

        code ⏰  awk -F"," '$2 > 500 && $2 < 1000 {print}' sales.csv > 1000.csv
        code ⏰  cat 1000.csv
        May,900
        November,934
        December,545

        code ⏰  awk -F"," '$2 > 1000 {print}' sales.csv > large.csv
        code ⏰  cat large.csv
        month,sales

The issue here is that we don't have any sales that is above 1000, but still, we have an entry in the large file. What happened here is the string got converted into number and then the comparison happened. We want to avoid that. For that, we need to filter out the header of the file while doing the processing.

Typically, you can use sed to delete the header.

        code ⏰  sed '1d' sales.csv

But because we are learning awk, we'll use awk to delete the header, or rather, ignore the header while processing the text.

        code ⏰  awk 'NR>1 {print}' sales.csv

NR: an internal awk variable which stores the line number of the file being processed.

        code ⏰  awk '{print NR, $0}' sales.csv
        1 month,sales
        2 Jan,100
        3 Feb,200
        4 March,100
        5 April,50
        6 May,900
        7 June,1000
        8 July,10
        9 August,20
        10 September,456
        11 October,134
        12 November,934
        13 December,545

* print all lines longer than 10 characters
        
        code ⏰  awk 'length > 10 {print}' sales.csv
        month,sales
        September,456
        October,134
        November,934
        December,545

Note: length($0) is equivalent to length.

Because we want to skip the header, we use the following command.

        code ⏰  awk 'NR>1 && length($0) > 10 {print}' sales.csv
        September,456
        October,134
        November,934
        December,545


* Finding max length of a file

        code ⏰  awk '{if (length($0)>max) max = length($0)} END {print "max length is ", max}' sales.csv
        max length is  13

The if condition is executed inside the first block

        {if (condition) statement}

Then, the END block gets executed at the end of the execution and we print the max length

* Ignore empty line

Add an empty line in sales.csv

        code ⏰  awk -F"," 'NF>1 {print}' sales.csv
        month,sales
        Jan,100
        Feb,200
        March,100
        April,50
        May,900
        June,1000
        July,10
        August,20
        September,456
        October,134
        November,934
        December,545

To see how this works, we must understand how NF works, which is obvious from the below script execution

        code ⏰  awk -F"," '{print NF, $0}' sales.csv
        2 month,sales
        2 Jan,100
        0
        2 Feb,200
        0
        2 March,100
        2 April,50
        2 May,900
        2 June,1000
        2 July,10
        2 August,20
        2 September,456
        2 October,134
        2 November,934
        2 December,545

* Print number of lines of a file

        code ⏰  awk 'END {print NR}' sales.csv
        15
        code ⏰  wc -l sales.csv
        15 sales.csv

Why this works?

We already have seen what NR stands for. Consider this, what will be the value of NR at the end of the file parsing? Yes, it'll be the line number of the last line.


* Print even odd lines

        code ⏰  awk 'NR % 2 == 0 {print}' sales.csv
        Jan,100
        Feb,200
        March,100
        May,900
        July,10
        September,456
        November,934

Change 0 to 1 in the above example and you'll find that the odd numbered lines are being printed

* Print the number of files that were updated in a particular month

You first need to find out in which all months have your files being updated on.

        awk book ⏰  ls -l | awk '{print $6}' | sort | uniq
        Dec
        Jul

Run the above command in your terminal. In my terminal, I have files updated only in Dec and Jul, so I'll use one of those in the below command


        awk book ⏰  ls -l | awk '{if ($6 == "Jul") x = x + 1} END {print x}'
        6
        awk book ⏰  ls -l | grep Jul | wc -l
        6

The first command can be rewritten as
        
        awk book ⏰  ls -l | awk '$6 == "Jul" { x = x + 1} END {print x}'

Note: Do check the output of `ls -l` on your terminal. $6 for me is the month in which the file was last updated, it could very well not be the same in your case.
